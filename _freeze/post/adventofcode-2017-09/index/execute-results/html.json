{
  "hash": "ccfff270fb00fffece544089aab497be",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: 'Advent of Code: 2017 Day 9'\ndescription: |\n  Stream Processing: Exploring different ways I took to solve this puzzle and alternative solutions\ndate: '2025-12-16'\ncategories:\n - Advent of Code\nimage: \"featured.svg\"\n---\n\n::: {.callout-warning}\nThis post will contain spoilers, including multiple solutions to the Advent of Code [2017 day 9](https://adventofcode.com/2017/day/9) puzzle. Proceed at your own risk.\n:::\n\nI will not spend much time going over the puzzle specification itself.\nPlease [read it yourself](https://adventofcode.com/2017/day/9) if you do not remember it.\n\nI enjoyed this puzzle quite a bit despite not doing too hot on it the first time around.\nI will go over the different paths I went on,\nfollowed by some other solutions I found afterwards.\n\n## Part 1\n\nThere are two parts to this one: we need to identify garbage and groups.\nCould this be handled in one go?\nMaybe, and it would be a lot harder!\nBeing able to identify what we need to do and how to do it is what separates the good from the great.\n\n### Garbage\n\nWe need to find the garbage and remove it, with the little wrinkle that `!` cancels the next character.\n\nMy original solution looks something like this:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"true\"}\nremove_garbage <- function(input) {\n  input_len <- length(input)\n  garbage <- logical(input_len)\n\n  i <- 1\n  start <- NA\n  end <- NA\n\n  while (i <= input_len) {\n    cur <- input[i]\n    if (cur == \"!\") {\n      i <- i + 2\n      next\n    }\n    if (cur == \"<\" && is.na(start)) {\n      start <- i\n    }\n    if (cur == \">\" && !is.na(start)) {\n      end <- i\n\n      garbage[seq(start, end)] <- TRUE\n      start <- NA\n      end <- NA\n    }\n    i <- i + 1\n  }\n\n  input[!garbage]\n}\n```\n:::\n\n\nThis assumes that the input has already been split into a character vector using `str_split_1(input, \"\")`.\n\nThe code should be fairly easy to follow:\n- We iterate over the character vector (line 9-10, 25)\n- If we see a `!`, we skip one value (line 11-14)\n- If we see a `<`, we denote the index as the starting location, but only do so if we haven't already set a starting location (line 15-17)\n- If we see a `>`, we check that we have a starting location; if one is set, then we denote the ending location. We then indicate the garbage using our found starting and ending location, resetting both, and continue (line 18-24)\n\nSince we know that garbage is also well structured, there shouldn't be any issues.\n\nThere shouldn't be any major issues with the code as it stands.\nThere are many small ways we can improve the above,\none of which is the lack of `else if`.\nUnless I absolutely have to, I don't really like how `else` looks in R.\n\nBut all of this doesn't matter because this part of the puzzle can be solved using regular expressions.\nAnd most of the time, when there is a regular expression problem, it is often pretty darn fast.\n\n```r\ninput |>\n  str_remove_all(\"!.\") |>\n  str_remove_all(\"<.*?>\")\n```\n\nWe now have 2 parts to it. First, we delete all the cancellations, then we delete the garbage.\nWe are lucky that regex follows the same conventions that we need here.\n`!.` removes each `!` followed by the next character.\nIt does it in order such that `<!!>` turns into `<>` because the second `!` is cancelled before it has time to cancel.\n\nNow that we have removed all the cancellations, we can remove the garbage. Finding all the sections of text that start with `<`, followed by any character `.`, zero or more times `*` until we see the next end `>`.\n\nCould we rewrite these two calls to `str_remove_all()` with a single one?\nProperly, but it would have made it much more complicated and way harder to reason about.\n\nThis change alone makes a HUGE difference in the speed and memory allocation between these two approaches!\n\n```r\n#> # A tibble: 2 × 13\n#>   expression      min   median `itr/sec` mem_alloc `gc/sec` n_itr\n#>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> <int>\n#> 1 fun          4.65ms   4.84ms      204.  467.87KB    33.7     85\n#> 2 regex      321.48µs 352.76µs     2824.    1.03KB     2.01  1407\n```\n\n### Groups\n\nWe need to identify the groups and then give each of them values and sum them.\n\nWe know from the puzzle specification that if we have removed the garbage correctly, all the groups will be properly formatted.\n\nMy first hunch for how to deal with this task is overly complicated.\nI tried treating this problem using recursion.\nI would start at the beginning of the sequence, then move along until I found the matching closing bracket, which would require keeping track of the levels.\nThen once I found a group, I would subset into the sequence `input[seq(start + 1, end - 1)]` and repeat in there.\nI never got the code to work before I realized I was over-engineering it.\n\nMy realization was that each group only needs to know its nesting level,\nnot what happened to the groups on the inside or the group it was inside.\n\nEach group has exactly one left `{` and one right `}`.\nEach left increase and each right decrease the point value.\nWe can then go through the sequence and increase the level each time we see an opening bracket, and decrease it each time we see a closing bracket.\n\nWe also need to capture how much each group is worth.\nThis should be done somewhere between the two steps above, \nafter we increase the value or before we decrease it.\n\nWe also see from the shown examples that empty groups are allowed.\nthe following group `{}` is identical to `{,}`,\nand `{{}}` is identical to `{,{}}`.\n\nWe can also show it a little bit graphically, like so:\n\n```md\n{{{},{},{{}}}}\n```\n\n```md\n {}\n {} {} {  }\n {  ,  ,    }\n{            }\n```\n\nAnother thing we notice is that we could completely ignore all the `,`s if we wanted to.\n\nThis brings me to my first solution:\n\n```r\ninput <- input[input != \",\"]\n\nres <- 0\nlevel <- 0\n\nfor (i in input) {\n  if (i == \"{\") {\n    level <- level + 1\n    res <- res + level\n  }\n  if (i == \"}\") {\n    level <- level - 1\n  }\n}\n\nres\n```\n\nWe first filter out all the commas as they aren't needed anymore.\nWhich very neatly followed the algorithms outlined earlier.\n\nAnother fun option would be to lean into using a `switch()`. It tightens up the `for` loop itself at the expense of a little more work beforehand and computational speed.\n\n```r\nres <- 0\nlevel <- 0\n\ninc <- function() {\n  level <<- level + 1\n}\ndec <- function() {\n  res <<- res + level\n  level <<- level - 1\n}\n  \nfor (i in input) {\n  switch(i, \"{\" = inc(), \"}\" = dec())\n}\n\nres\n```\n\nBoth of these solutions are very generic programming solutions.\nThat could be translated word-for-word into most other languages and would work perfectly fine.\n\nLet us now see if we can use some more R-specific tools and vectorize this task.\n\nWe are looking at the change in level over time. We could use `cumsum()` if we properly encode the vector itself.\nThen it is simply a matter of finding the beginning of each group and summing the values.\nGiving us this final solution.\n\n```r\nchanges <- c(\"}\" = -1, \"{\" = 1, \",\" = 0)[input]\nlevels <- cumsum(changes)\nstarts <- levels[input == \"{\"]\nsum(starts)\n```\n\nAll the solutions are good by themselves.\n\n```r\n#> # A tibble: 3 × 13\n#>   expression      min   median `itr/sec` mem_alloc `gc/sec`\n#>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n#> 1 ifelse      207.5µs  237.9µs     4081.    68.9KB     12.5\n#> 2 switch        463µs  512.5µs     1937.        0B     10.2\n#> 3 cumsum       40.3µs   51.9µs    19218.   206.3KB     99.1\n```\n\n## Part 2\n\nWe now need to identify how much of the input was garbage. Specifically excluding the cancellations.\n\nMy first solution was very `for` and `if` heavy.\nworking with the character vector produced with `str_split_1(input, \"\")`.\n\n```r\ngarbage <- logical(length(input))\n\ninside <- FALSE\ni <- 1\n\nwhile (i <= length(input)) {\n  garbage[i] <- inside\n\n  cur <- input[i]\n\n  if (cur == \"<\") {\n    inside <- TRUE\n  } else if (cur == \">\") {\n    inside <- FALSE\n    garbage[i] <- FALSE\n  } else if (cur == \"!\") {\n    garbage[i] <- FALSE\n    garbage[i + 1] <- FALSE\n    i <- i + 1\n  }\n  i <- i + 1\n}\n\nsum(garbage)\n```\n\nGenerate a garbage logical vector,\nThen going over line by line to either denote something as garbage or not.\n\nAs you have properly realized, we can use regular expressions again.\nSwitching the second `str_remove_all()` with `str_extract_all()` gives us all the garbage, then it is simply a matter of calculating their lengths, remembering that the start and end don't count.\n\n```r\ninput |>\n  str_remove_all(\"!.\") |>\n  str_extract_all(\"<.*?>\") |>\n  lapply(\\(x) nchar(x) - 2) |>\n  unlist() |>\n  sum()\n```\n\nThis solution fits a single pipe and is a little bit faster as well.\n\n```r\n#> # A tibble: 2 × 13\n#>   expression      min   median `itr/sec` mem_alloc `gc/sec`\n#>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n#> 1 old          3.61ms   3.69ms      267.   230.5KB    27.4 \n#> 2 new        315.78µs 346.86µs     2880.    20.8KB     2.01\n```\n\n## Roundup\n\nI don't know if you learned anything. Sorry if you didn't. But I hope you had fun, which is all that Advent of Code is about.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}