{
  "hash": "f7206fd5c232032c21b285aa588ffada",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: 'Fun Feature Engineering with Gen 1 Pokémon'\ndescription: |\n A tidytuesday inspired feature engineering journey into Pokémon \ndate: '2024-04-05'\ncategories:\n  - Feature Engineering\n  - tidy Tuesday\nimage: \"featured.png\"\n---\n\n\n\nI had the idea behind this blog post for a while,\nbut [tidytuesday](https://github.com/rfordatascience/tidytuesday/blob/main/data/2025/2025-04-01/readme.md) was doing Pokemon data this week I had to do it.\nI have been thinking about [Feature Engineering](https://feaz-book.com/) for a while now,\nand the idea of using data about something I like and know about seems like a perfect match.\n\nThe general idea in this post is to apply different transformations to the data and see how reveals structure and similarity in the data.\nSince we don't have a specific target in mind,\nI will be using [UMAP](https://umap-learn.readthedocs.io/en/latest/) on the different data sets.\nThen we can look at the placements to see if we can recognize what happened in the transformation. \n\n::: {.callout-note}\nI'm fully aware of the pros and cons of using UMAP.\nThis is a toy example and you will find that it serves its purpose fine for this post.\n:::\n\nFor ease of visualization, I will only be using Generation 1 (first 151) Pokemon.\nPartly to avoid overplotting and because those are the most well-known Pokemon for the readers.\n\n## Packages and data\n\nWe load tidyverse for wrangling and plotting, ggimage to add pokemon as sprites, recipes, and embed to perform feature engineering including UMAP, pokemon for the data sources, fs for file system operations since I will be working with some images as well, patchwork to combine some charts, png to read png files.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(ggimage)\nlibrary(recipes)\nlibrary(embed)\nlibrary(pokemon)\nlibrary(fs)\nlibrary(patchwork)\nlibrary(png)\n```\n:::\n\n\n\nThen we filter the data down to only include generation 1,\nThe `generation_id` column comes in handy for this.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npokemon <- pokemon |>\n  filter(generation_id == 1)\nglimpse(pokemon)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 151\nColumns: 22\n$ id              <dbl> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,…\n$ pokemon         <chr> \"bulbasaur\", \"ivysaur\", \"venusaur\", \"charmander\", \"cha…\n$ species_id      <dbl> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,…\n$ height          <dbl> 0.7, 1.0, 2.0, 0.6, 1.1, 1.7, 0.5, 1.0, 1.6, 0.3, 0.7,…\n$ weight          <dbl> 6.9, 13.0, 100.0, 8.5, 19.0, 90.5, 9.0, 22.5, 85.5, 2.…\n$ base_experience <dbl> 64, 142, 236, 62, 142, 240, 63, 142, 239, 39, 72, 178,…\n$ type_1          <chr> \"grass\", \"grass\", \"grass\", \"fire\", \"fire\", \"fire\", \"wa…\n$ type_2          <chr> \"poison\", \"poison\", \"poison\", NA, NA, \"flying\", NA, NA…\n$ hp              <dbl> 45, 60, 80, 39, 58, 78, 44, 59, 79, 45, 50, 60, 40, 45…\n$ attack          <dbl> 49, 62, 82, 52, 64, 84, 48, 63, 83, 30, 20, 45, 35, 25…\n$ defense         <dbl> 49, 63, 83, 43, 58, 78, 65, 80, 100, 35, 55, 50, 30, 5…\n$ special_attack  <dbl> 65, 80, 100, 60, 80, 109, 50, 65, 85, 20, 25, 90, 20, …\n$ special_defense <dbl> 65, 80, 100, 50, 65, 85, 64, 80, 105, 20, 25, 80, 20, …\n$ speed           <dbl> 45, 60, 80, 65, 80, 100, 43, 58, 78, 45, 30, 70, 50, 3…\n$ color_1         <chr> \"#78C850\", \"#78C850\", \"#78C850\", \"#F08030\", \"#F08030\",…\n$ color_2         <chr> \"#A040A0\", \"#A040A0\", \"#A040A0\", NA, NA, \"#A890F0\", NA…\n$ color_f         <chr> \"#81A763\", \"#81A763\", \"#81A763\", NA, NA, \"#DE835E\", NA…\n$ egg_group_1     <chr> \"monster\", \"monster\", \"monster\", \"monster\", \"monster\",…\n$ egg_group_2     <chr> \"plant\", \"plant\", \"plant\", \"dragon\", \"dragon\", \"dragon…\n$ url_icon        <chr> \"//archives.bulbagarden.net/media/upload/7/7b/001MS6.p…\n$ generation_id   <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, …\n$ url_image       <chr> \"https://raw.githubusercontent.com/HybridShivam/Pokemo…\n```\n\n\n:::\n:::\n\n\n\nTo make the visualizations easy to read I'm going to be using small sprites or each Pokemon as their plotting.\nI'll download them for easy use using the below code.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsprites_urls <- paste0(\"https:\", pokemon$url_icon)\n\nsprites_path <- fs::path(\n  \"sprites\", \n pokemon$pokemon, \n ext = \"png\"\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nwalk2(sprites_urls, sprites_path, slowly(download.file))\n```\n:::\n\n\n\nThen we create a tibble of all the sprites we just downloaded with matching names.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsprites_tbl <- tibble(\n pokemon = pokemon$pokemon,\n sprite = sprites_path\n)\nsprites_tbl\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 151 × 2\n   pokemon    sprite                \n   <chr>      <fs::path>            \n 1 bulbasaur  sprites/bulbasaur.png \n 2 ivysaur    sprites/ivysaur.png   \n 3 venusaur   sprites/venusaur.png  \n 4 charmander sprites/charmander.png\n 5 charmeleon sprites/charmeleon.png\n 6 charizard  sprites/charizard.png \n 7 squirtle   sprites/squirtle.png  \n 8 wartortle  sprites/wartortle.png \n 9 blastoise  sprites/blastoise.png \n10 caterpie   sprites/caterpie.png  \n# ℹ 141 more rows\n```\n\n\n:::\n:::\n\n\n\nNow we are ready to get to plotting.\n\n## Random - how to plot Pokemon sprites\n\nI'm using the ggimage package to add the Pokemon as sprites.\nWith this, we can use `geom_image()` which takes an aesthetic `image` which should be a path to an image.\nLastly, we need to change the `size` used in `geom_image()` as the default is way too large for what we are trying to do.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\n\nsprites_tbl |>\n  mutate(\n x = rnorm(151),\n y = rnorm(151),\n ) |>\n  ggplot(aes(x, y)) + \n  geom_image(aes(image = sprite), size = .1)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n\nSince the axes won't have any meaning because we are using UMAP,\nWe will be using `theme_void()` to remove everything,\nalong wit `theme()` and `labs()` to add a simple title.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\nsprites_tbl |>\n  mutate(\n x = rnorm(151),\n y = rnorm(151),\n ) |>\n  ggplot(aes(x, y)) + \n  geom_image(aes(image = sprite), size = .1) +\n  theme_void() +\n  theme(plot.title = element_text(hjust = 0.5)) +\n  labs(title = \"Random Position\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n\nThe only difference moving forward will be the data we pass in,\nso I'll create a little helper function to do our plotting.\nUsing `aes(UMAP1, UMAP2)` instead of `aes(x, y)` since I know that is the name that will come out of recipes by default.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npokemon_umap_plot <- function(data, title) {\n data |>\n    ggplot(aes(UMAP1, UMAP2)) + \n    geom_image(aes(image = sprite), size = .1) +\n    theme_void() +\n    theme(plot.title = element_text(hjust = 0.5)) +\n    labs(title = title)\n}\n```\n:::\n\n\n\n## Stats\n\nFirst, we will see what happens when we just look at the 6 main [stats](https://bulbapedia.bulbagarden.net/wiki/Stat#List_of_stats).\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nset.seed(1)\npokemon |>\n  select(pokemon, hp:speed) |>\n  recipe() |>\n  step_umap(all_numeric()) |>\n  prep() |>\n  bake(NULL) |>\n  left_join(sprites_tbl, by = join_by(pokemon)) |>\n  pokemon_umap_plot(\"Stats\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n\nRemember that UMAP mostly cares about local distances.\nSo left-right up-down doesn't mean much,\ninstead, we look at if neighboring Pokemon have similar data which for this plot is stats.\n\nWe can verify this by seeing that all legendary Pokemon, [Articuno](https://bulbapedia.bulbagarden.net/wiki/Articuno_(Pok%C3%A9mon)), [Zapdos](https://bulbapedia.bulbagarden.net/wiki/Zapdos_(Pok%C3%A9mon)), [Moltres](https://bulbapedia.bulbagarden.net/wiki/Moltres_(Pok%C3%A9mon)), and [Mewtwo](https://bulbapedia.bulbagarden.net/wiki/Mewtwo_(Pok%C3%A9mon)) are hanging out on the right side near a lot high stated pokemon. \nAnd the left-hand side appears to have some low stated Pokemon with [Weedle](https://bulbapedia.bulbagarden.net/wiki/Weedle_(Pok%C3%A9mon)), [Caterpie](https://bulbapedia.bulbagarden.net/wiki/Caterpie_(Pok%C3%A9mon)), and [Magikarp](https://bulbapedia.bulbagarden.net/wiki/Magikarp_(Pok%C3%A9mon)).\n\n## Stats - normalized\n\nBefore we use the stats by themselves,\nlet us see if something happens if we normalize them.\nNormalizing here is specifically meant as a part of the total stat distribution. \nThis should hopefully mean that a Pokemon that is very fast would be near other fast Pokemon, regardless of whether its total stats are high or low.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nset.seed(1)\npokemon |>\n  select(pokemon, hp:speed) |>\n   mutate(total = rowSums(across(where(is.numeric)))) |>\n  mutate(across(hp:speed, \\(x) x / total)) |>\n  select(-total) |>\n  recipe() |>\n  step_umap(all_numeric()) |>\n  prep() |>\n  bake(NULL) |>\n  left_join(sprites_tbl, by = join_by(pokemon)) |>\n  pokemon_umap_plot(\"Stats normalized by total\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n\nThe main difference I see is that Pokemon from their evolutionary family stay together.\n[Krabby](https://bulbapedia.bulbagarden.net/wiki/Krabby_(Pok%C3%A9mon)) and [Kingler](https://bulbapedia.bulbagarden.net/wiki/Kingler_(Pok%C3%A9mon)), [Ponyta](https://bulbapedia.bulbagarden.net/wiki/Ponyta_(Pok%C3%A9mon)) and [Rapidash](https://bulbapedia.bulbagarden.net/wiki/Rapidash_(Pok%C3%A9mon)), [Omanyte](https://bulbapedia.bulbagarden.net/wiki/Omanyte_(Pok%C3%A9mon)) and [Omastar](https://bulbapedia.bulbagarden.net/wiki/Omastar_(Pok%C3%A9mon)).\nThis feels right as you would expect many Pokemon to preserve their stat spread when evolving.\n\n## Moves\n\nI went ahead a [scraped](scrape.R) from [The RESTful Pokémon API](https://pokeapi.co/) some more data than what came in the package.\nI wanted to look at their moves and see what happens with them.\nThe data set contains one row for each Pokemon and one column for each move. \nA 1 indicates whether the Pokemon can learn that move.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmoves <- read_csv(\n  \"moves.csv\", \n show_col_types = FALSE\n)\n\nmoves\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 151 × 593\n   name  razor_wind swords_dance   cut  bind vine_whip headbutt tackle body_slam\n   <chr>      <dbl>        <dbl> <dbl> <dbl>     <dbl>    <dbl>  <dbl>     <dbl>\n 1 bulb…          1            1     1     1         1        1      1         1\n 2 cate…          0            0     0     0         0        0      1         0\n 3 volt…          0            0     0     0         0        1      1         0\n 4 elec…          0            0     0     0         0        1      1         0\n 5 exeg…          0            1     0     0         0        1      0         0\n 6 exeg…          0            1     0     0         0        1      0         1\n 7 cubo…          0            1     0     0         0        1      0         1\n 8 maro…          0            1     0     0         0        1      0         1\n 9 hitm…          0            1     0     0         0        1      1         1\n10 hitm…          0            1     0     0         0        1      1         1\n# ℹ 141 more rows\n# ℹ 584 more variables: take_down <dbl>, double_edge <dbl>, growl <dbl>,\n#   strength <dbl>, mega_drain <dbl>, leech_seed <dbl>, growth <dbl>,\n#   razor_leaf <dbl>, solar_beam <dbl>, poison_powder <dbl>,\n#   sleep_powder <dbl>, petal_dance <dbl>, string_shot <dbl>, toxic <dbl>,\n#   rage <dbl>, mimic <dbl>, double_team <dbl>, defense_curl <dbl>,\n#   light_screen <dbl>, reflect <dbl>, bide <dbl>, sludge <dbl>, …\n```\n\n\n:::\n:::\n\n\n\nWe use the same UMAP on these predictors now.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nset.seed(1)\nmoves |>\n  recipe() |>\n  step_umap(all_numeric()) |>\n  prep() |>\n  bake(NULL) |>\n  left_join(sprites_tbl, by = c(\"name\" = \"pokemon\")) |>\n  pokemon_umap_plot(\"Moves\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\n\nAnd it appears that it is working as intended.\nWe again see evolution likes close to each other which makes sense,\nwe also see a little bit of a color clustering which could be explained a little by the fact that a lot of Pokemon of the same types have similar colors.\nThe last thing I wanted to point out is that it perfectly captures the Pokemon that doens't learn many moves including; [Ditto](https://bulbapedia.bulbagarden.net/wiki/Ditto_(Pok%C3%A9mon)), [Kakuna](https://bulbapedia.bulbagarden.net/wiki/Kakuna_(Pok%C3%A9mon)), and [Magikarp](https://bulbapedia.bulbagarden.net/wiki/Magikarp_(Pok%C3%A9mon)).\n\n## Moves types\n\nEach move has metadata associated with it. \nLet's see what we can pull out of this.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmoves_meta <- read_csv(\n  \"moves-meta.csv\", \n show_col_types = FALSE\n)\n\nmoves_meta\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 592 × 4\n   moves        type   priority category      \n   <chr>        <chr>     <dbl> <chr>         \n 1 razor_wind   normal        0 damage        \n 2 swords_dance normal        0 net-good-stats\n 3 cut          normal        0 damage        \n 4 bind         normal        0 damage+ailment\n 5 vine_whip    grass         0 damage        \n 6 headbutt     normal        0 damage        \n 7 tackle       normal        0 damage        \n 8 body_slam    normal        0 damage+ailment\n 9 take_down    normal        0 damage        \n10 double_edge  normal        0 damage        \n# ℹ 582 more rows\n```\n\n\n:::\n:::\n\n\n\nWe look at how many of each type a Pokemon can learn.\nE.i. how many grass type moves does it learn, how many fire time moves does it learn, etc etc.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(5)\nmoves |>\n  pivot_longer(cols = -name, names_to = \"moves\") |>\n  filter(value == 1) |>\n  left_join(moves_meta, by = join_by(moves)) |>\n  count(name, type) |>\n  pivot_wider(names_from = type, values_from = n, values_fill = 0) |>\n  recipe() |>\n  step_umap(all_numeric()) |>\n  prep() |>\n  bake(NULL) |>\n  left_join(sprites_tbl, by = c(\"name\" = \"pokemon\")) |>\n  pokemon_umap_plot(\"Number of Moves by Type\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n\nThis one is very skewed by the handful of Pokemon that don't know any moves.\n\n## Move types normalized\n\nWe do the same normalization we talked about earlier.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nset.seed(2)\nmoves |>\n  pivot_longer(cols = -name, names_to = \"moves\") |>\n  filter(value == 1) |>\n  left_join(moves_meta, by = join_by(moves)) |>\n  count(name, type) |>\n  pivot_wider(names_from = type, values_from = n, values_fill = 0) |>\n  mutate(total = rowSums(across(where(is.numeric)))) |>\n  mutate(across(where(is.numeric), \\(x) x / total)) |>\n  select(-total) |>\n  recipe() |>\n  step_umap(all_numeric()) |>\n  prep() |>\n  bake(NULL) |>\n  left_join(sprites_tbl, by = c(\"name\" = \"pokemon\")) |>\n  pokemon_umap_plot(\"Number of Moves by Type - Normalized\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n\nThere might be a bit more separation.\nOne thing to point out here is that it looks very similar to the moves embedding, \nbut this is done on 18 columns (1 for each type) which is a lot less than moves alone which contains 592 columns.\n\n## Move Category\n\nI extracted a category field as well.\nThis one lets us see what type of move it is in broad categories.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmoves_meta |>\n  count(category)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 15 × 2\n   category               n\n   <chr>              <int>\n 1 ailment               29\n 2 damage               245\n 3 damage+ailment        62\n 4 damage+heal            7\n 5 damage+lower          39\n 6 damage+raise          16\n 7 field-effect          12\n 8 force-switch           2\n 9 heal                  10\n10 net-good-stats        52\n11 ohko                   4\n12 swagger                2\n13 unique                79\n14 whole-field-effect    15\n15 <NA>                  18\n```\n\n\n:::\n:::\n\n\n\nWe will use it the same as before.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nset.seed(5)\nmoves |>\n  pivot_longer(cols = -name, names_to = \"moves\") |>\n  filter(value == 1) |>\n  left_join(moves_meta, by = join_by(moves)) |>\n  count(name, category) |>\n  pivot_wider(names_from = category, values_from = n, values_fill = 0) |>\n  recipe() |>\n  step_umap(all_numeric()) |>\n  prep() |>\n  bake(NULL) |>\n  left_join(sprites_tbl, by = c(\"name\" = \"pokemon\")) |>\n  pokemon_umap_plot(\"Number of Moves by Category\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n\nI find this one harder to analyze,\nI'm not able to many trends in this data set beyond our useless friends.\n\n## Move Category normalized\n\nIf we normalize the above we get the following.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nset.seed(5)\nmoves |>\n  pivot_longer(cols = -name, names_to = \"moves\") |>\n  filter(value == 1) |>\n  left_join(moves_meta, by = join_by(moves)) |>\n  count(name, category) |>\n  pivot_wider(names_from = category, values_from = n, values_fill = 0) |>\n  mutate(total = rowSums(across(where(is.numeric)))) |>\n  mutate(across(where(is.numeric), \\(x) x / total)) |>\n  select(-total) |>\n  recipe() |>\n  step_umap(all_numeric()) |>\n  prep() |>\n  bake(NULL) |>\n  left_join(sprites_tbl, by = c(\"name\" = \"pokemon\")) |>\n  pokemon_umap_plot(\"Number of Moves by Category - normalized\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\n\nWhat I like about this one is that you see Pokemon from the same evolution lines near each other.\nAs well as the legendary birds together in the middle.\n\n## Sprites\n\nLastly, let's see what we can do with the sprites.\nThis will be a very rough approach.\nI'm going to count the number of colors for each pixel in the images from the `Pokemon` data set and use those counts as the input to UMAP.\n\nBelow is the code used to download the images.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nimage_urls <- pokemon$url_image\n\nimage_path <- fs::path(\n  \"images\", \n pokemon$pokemon, \n ext = \"png\"\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nwalk2(image_urls, image_path, slowly(download.file))\n```\n:::\n\n\n\nI wrote a little helper function to get pixel color counts.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncount_colors <- function(path, name) {\n png <- readPNG(path)\n color <- rgb(png[,,1], png[,,2], png[,,3])\n res <- tibble(color) |>\n    count(color)\n    \n  bind_cols(\n name = name,\n res\n )\n} \n```\n:::\n\n\n\nNow we are ready to use the data.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nset.seed(1)\nmap2(\n image_path, \n pokemon$pokemon, \n count_colors\n) |>\n  list_rbind() |>\n  filter(color != \"#000000\") |>\n  pivot_wider(names_from = color, values_from = n, values_fill = 0) |>\n  recipe() |>\n  step_umap(all_numeric()) |>\n  prep() |>\n  bake(NULL) |>\n  left_join(sprites_tbl, by = c(\"name\" = \"pokemon\")) |>\n  pokemon_umap_plot(\"Number of Moves by Type\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\n\nWhat we see right away is that something didn't work right.\nA likely explanation is that the precise colors were too specific, \nand we thus didn't see enough overlap between the Pokemon for UMAP to pick up on.\n\nLet's try to round the colors a bit after there are 16,777,216 (`16 ^ 6`) colors. Lets instead round them,\nso instead of using two hex values per color, we just use the more important one.\nThis will leave us with 4096 (`16 * 16 * 16`) colors.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nset.seed(1)\nmap2(\n image_path, \n pokemon$pokemon, \n count_colors) |>\n  list_rbind() |>\n  mutate(color = paste0(\n    str_sub(color, 1, 2), \n    str_sub(color, 3, 3),\n    str_sub(color, 5, 5)\n )\n ) |>\n    mutate(color = str_replace_all(\n color, \n      c(\n        \"0\" = \"0\", \n        \"1\" = \"0\",\n        \"2\" = \"0\",\n        \"3\" = \"0\",\n        \"4\" = \"1\", \n        \"5\" = \"1\",\n        \"6\" = \"1\",\n        \"7\" = \"1\",\n        \"8\" = \"2\", \n        \"9\" = \"2\",\n        \"A\" = \"2\",\n        \"B\" = \"2\",\n        \"C\" = \"3\", \n        \"D\" = \"3\",\n        \"E\" = \"3\",\n        \"F\" = \"3\"\n )\n )\n ) |>\n  count(name, color, wt = n) |>\n  filter(color != \"#000\") |>\n  pivot_wider(names_from = color, values_from = n, values_fill = 0) |>\n  recipe() |>\n  step_umap(all_numeric()) |>\n  prep() |>\n  bake(NULL) |>\n  left_join(sprites_tbl, by = c(\"name\" = \"pokemon\")) |>\n  pokemon_umap_plot(\"Number of Moves by Type\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n:::\n\n\n\nThe results are better as there now is a color separation between the Pokemon.\nLet's see what would happen if we discretize the colors even more. \nBelow each color channel (red, green, blue) is made to only contain 4 different values,\nleaving us with 64 unique colors to be counted.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nset.seed(1)\nmap2(\n image_path, \n pokemon$pokemon, \n count_colors) |>\n  list_rbind() |>\n  mutate(color = paste0(\n    str_sub(color, 1, 2), \n    str_sub(color, 3, 3),\n    str_sub(color, 5, 5)\n )\n ) |>\n    mutate(color = str_replace_all(\n color, \n      c(\n        \"0\" = \"0\", \n        \"1\" = \"0\",\n        \"2\" = \"0\",\n        \"3\" = \"0\",\n        \"4\" = \"1\", \n        \"5\" = \"1\",\n        \"6\" = \"1\",\n        \"7\" = \"1\",\n        \"8\" = \"2\", \n        \"9\" = \"2\",\n        \"A\" = \"2\",\n        \"B\" = \"2\",\n        \"C\" = \"3\", \n        \"D\" = \"3\",\n        \"E\" = \"3\",\n        \"F\" = \"3\"\n )\n )\n ) |>\n  count(name, color, wt = n) |>\n  filter(color != \"#000\") |>\n  pivot_wider(names_from = color, values_from = n, values_fill = 0) |>\n    mutate(total = rowSums(across(where(is.numeric)))) |>\n  mutate(across(where(is.numeric), \\(x) x / total)) |>\n  select(-total) |>\n  recipe() |>\n  step_umap(all_numeric()) |>\n  prep() |>\n  bake(NULL) |>\n  left_join(sprites_tbl, by = c(\"name\" = \"pokemon\")) |>\n  pokemon_umap_plot(\"Number of Moves by Type\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n\n\nThis worked pretty well considering how limited RGB color space is for these types of analysis.\n\n## Further ideas\n\nIn no particular order\n\n- co-occurrence in moves\n- Resistances\n- Body style, exp rates, potential (what they can be envolve into)\n- types\n    - Full resistances\n    - combinations\n- text embedding\n- image embeddings\n    - so many things to do here\n    - actual embeddings\n    - different color spaces\n- what types can this Pokemon hit with the moves it can learn\n    - can it hit or not for each type\n    - how many moves can hit count vs percentage\n    - highest dmg value for the attack that hits each type\n\n## Other similar work\n\n- https://gibsramen.github.io/gUMAP/docs/pokemon.html\n- https://minimaxir.com/2024/06/pokemon-embeddings/",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}